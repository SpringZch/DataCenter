//
// Generated file, do not edit! Created by opp_msgc 4.3 from model/packets/ControlMessage.msg.
//

#ifndef _CONTROLMESSAGE_M_H_
#define _CONTROLMESSAGE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0403
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#define BROADCAST_ADDRESS		((uint)-1)

#define BROADCAST_SWITCHES		((uint)-2)

#define BROADCAST_ADDRESS_RANGE ((uint)-2)
// }}



/**
 * Enum generated from <tt>model/packets/ControlMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum ControlMessageType
 * {
 *     CONTROL_MESSAGE_BASE_KIND	= 1;
 * 	TRAFFIC_SOURCE_CONTROL_MSG	= 2;
 * 	UPDATE_SENDING_RATE_MSG		= 3;
 * 	UPDATE_QUEUE_SIZE_MSG		= 4;
 * 	SCHEDULING_CONTROL_MSG		= 5;
 * 	TENANT_SERVERS_MSG			= 6;
 * }
 * </pre>
 */
enum ControlMessageType {
    CONTROL_MESSAGE_BASE_KIND = 1,
    TRAFFIC_SOURCE_CONTROL_MSG = 2,
    UPDATE_SENDING_RATE_MSG = 3,
    UPDATE_QUEUE_SIZE_MSG = 4,
    SCHEDULING_CONTROL_MSG = 5,
    TENANT_SERVERS_MSG = 6
};

/**
 * Class generated from <tt>model/packets/ControlMessage.msg</tt> by opp_msgc.
 * <pre>
 * message ControlMessage {
 *     @customize(true);
 *     unsigned int srcAddr;
 *     unsigned int dstAddr;
 *     string srcSubModule;
 *     string dstSubModule;
 *     unsigned short type enum(ControlMessageType) = CONTROL_MESSAGE_BASE_KIND;
 * };
 * </pre>
 *
 * ControlMessage_Base is only useful if it gets subclassed, and ControlMessage is derived from it.
 * The minimum code to be written for ControlMessage is the following:
 *
 * <pre>
 * class ControlMessage : public ControlMessage_Base
 * {
 *   private:
 *     void copy(const ControlMessage& other) { ... }

 *   public:
 *     ControlMessage(const char *name=NULL, int kind=0) : ControlMessage_Base(name,kind) {}
 *     ControlMessage(const ControlMessage& other) : ControlMessage_Base(other) {copy(other);}
 *     ControlMessage& operator=(const ControlMessage& other) {if (this==&other) return *this; ControlMessage_Base::operator=(other); copy(other); return *this;}
 *     virtual ControlMessage *dup() const {return new ControlMessage(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from ControlMessage_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(ControlMessage);
 * </pre>
 */
class ControlMessage_Base : public ::cMessage
{
  protected:
    unsigned int srcAddr_var;
    unsigned int dstAddr_var;
    opp_string srcSubModule_var;
    opp_string dstSubModule_var;
    unsigned short type_var;

  private:
    void copy(const ControlMessage_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ControlMessage_Base&);
    // make constructors protected to avoid instantiation
    ControlMessage_Base(const char *name=NULL, int kind=0);
    ControlMessage_Base(const ControlMessage_Base& other);
    // make assignment operator protected to force the user override it
    ControlMessage_Base& operator=(const ControlMessage_Base& other);

  public:
    virtual ~ControlMessage_Base();
    virtual ControlMessage_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class ControlMessage");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getSrcAddr() const;
    virtual void setSrcAddr(unsigned int srcAddr);
    virtual unsigned int getDstAddr() const;
    virtual void setDstAddr(unsigned int dstAddr);
    virtual const char * getSrcSubModule() const;
    virtual void setSrcSubModule(const char * srcSubModule);
    virtual const char * getDstSubModule() const;
    virtual void setDstSubModule(const char * dstSubModule);
    virtual unsigned short getType() const;
    virtual void setType(unsigned short type);
};


#endif // _CONTROLMESSAGE_M_H_
